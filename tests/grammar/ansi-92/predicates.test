# simple equality comparison predicate
>SELECT * FROM t1 WHERE a = 10
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[10]>
# anti-equality comparison predicate
>SELECT * FROM t1 WHERE a <> 10
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] <> literal[10]>
# Order of value expressions should not matter in equality comparison
>SELECT * FROM t1 WHERE 10 = a
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     literal[10] = column-reference[a]>
# Compound predicate with AND of two equality comparison predicates
>SELECT * FROM t1 WHERE a = 1 AND b = 2
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] AND column-reference[b] = literal[2]>
# Compound predicate with OR of two equality comparison predicates
>SELECT * FROM t1 WHERE a = 1 OR b = 2
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] OR column-reference[b] = literal[2]>
# Compound predicate with both AND and OR operators
>SELECT * FROM t1 WHERE a = 1 AND b = 2 OR c = 3
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] AND column-reference[b] = literal[2] OR column-reference[c] = literal[3]>
# Compound predicate with both OR and AND operators. The AND should take
# precedence
>SELECT * FROM t1 WHERE a = 1 OR b = 2 AND c = 3
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] OR column-reference[b] = literal[2] AND column-reference[c] = literal[3]>
# Compound predicate with both AND and OR operators using parens for precedence
# override
>SELECT * FROM t1 WHERE a = 1 AND (b = 2 OR c = 3)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] AND (column-reference[b] = literal[2] OR column-reference[c] = literal[3])>
# Multiple nested search conditions using parens for precedence
>SELECT * FROM t1 WHERE a = 1 AND (b = 2 OR c = 3 AND (d = 4 OR e = 5))
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] = literal[1] AND (column-reference[b] = literal[2] OR column-reference[c] = literal[3] AND (column-reference[d] = literal[4] OR column-reference[e] = literal[5]))>
# IN (<value list>) operator with single value
>SELECT * FROM t1 WHERE a IN (1)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] IN (literal[1])>
# Negate of IN (<value list>) operator with single value
>SELECT * FROM t1 WHERE a NOT IN (1)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] NOT IN (literal[1])>
# top-level negation of IN (<value list>) operator with single value
>SELECT * FROM t1 WHERE NOT a IN (1)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     NOT column-reference[a] IN (literal[1])>
# double-negation of IN (<value list>) operator with single value
>SELECT * FROM t1 WHERE NOT a NOT IN (1)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     NOT column-reference[a] NOT IN (literal[1])>
# IN (<value list>) operator with multiple value
>SELECT * FROM t1 WHERE a IN (1, 2, 3)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] IN (literal[1],literal[2],literal[3])>
# IN (<value list>) operator with complex value expressions
>SELECT * FROM t1 WHERE a IN (1 - b, CHAR_LENGTH(b))
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] IN (numeric-expression[literal[1] - column-reference[b]],char-length[column-reference[b]])>
# IN (<subquery>) operator
>SELECT * FROM t1 WHERE a IN (SELECT t1_a FROM t2)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] IN <statement: SELECT
   selected columns:
     0: column-reference[t1_a]
   referenced tables:
     0: t2>>
# EXISTS (<subquery>) predicate
>SELECT * FROM t1 WHERE EXISTS (SELECT t1_id FROM t2 WHERE t1_id = t1.id)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
      EXISTS <statement: SELECT
   selected columns:
     0: column-reference[t1_id]
   referenced tables:
     0: t2
   where:
     column-reference[t1_id] = column-reference[t1.id]>>
# <row> MATCH (<subquery>) predicate
>SELECT * FROM t1 WHERE id MATCH (SELECT t1_id FROM t2 WHERE t1_id = t1.id)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[id] MATCH FULL <statement: SELECT
   selected columns:
     0: column-reference[t1_id]
   referenced tables:
     0: t2
   where:
     column-reference[t1_id] = column-reference[t1.id]>>
# <row> MATCH (<subquery>) predicate explicit FULL
>SELECT * FROM t1 WHERE id MATCH FULL (SELECT t1_id FROM t2 WHERE t1_id = t1.id)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[id] MATCH FULL <statement: SELECT
   selected columns:
     0: column-reference[t1_id]
   referenced tables:
     0: t2
   where:
     column-reference[t1_id] = column-reference[t1.id]>>
# <row> MATCH (<subquery>) predicate with UNIQUE
>SELECT * FROM t1 WHERE id MATCH UNIQUE (SELECT t1_id FROM t2 WHERE t1_id = t1.id)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[id] MATCH UNIQUE FULL <statement: SELECT
   selected columns:
     0: column-reference[t1_id]
   referenced tables:
     0: t2
   where:
     column-reference[t1_id] = column-reference[t1.id]>>
# <row> MATCH (<subquery>) predicate explicit PARTIAL
>SELECT * FROM t1 WHERE id MATCH PARTIAL (SELECT t1_id FROM t2 WHERE t1_id = t1.id)
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[id] MATCH PARTIAL <statement: SELECT
   selected columns:
     0: column-reference[t1_id]
   referenced tables:
     0: t2
   where:
     column-reference[t1_id] = column-reference[t1.id]>>
# LIKE predicate with simple column comparison with string
>SELECT * FROM t1 WHERE a LIKE 's%'
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] LIKE literal['s%']>
# LIKE predicate with concatenated column comparison with string
>SELECT * FROM t1 WHERE a LIKE b || '%'
OK
statements[0]:
  <statement: SELECT
   selected columns:
     0: *
   referenced tables:
     0: t1
   where:
     column-reference[a] LIKE concatenate[column-reference[b], literal['%']]>
