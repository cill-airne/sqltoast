// DO NOT EDIT. Only edit the lnclude/sqltoast.h.in file, since sqltoast.h is
// generated during build.
#ifndef SQLTOAST_H
#define SQLTOAST_H

#define SQLTOAST_VERSION_MAJOR @SQLTOAST_VERSION_MAJOR@
#define SQLTOAST_VERSION_MINOR @SQLTOAST_VERSION_MINOR@

#if defined(__GNUC__) || defined(__clang__)
#define SQLTOAST_UNREACHABLE() __builtin_unreachable()
#else
#define SQLTOAST_UNREACHABLE() assert(!"code should not be reachable")
#endif

#include <memory>
#include <string>
#include <vector>

#include "statement.h"

namespace sqltoast {

// Dialects of SQL that can be parsed by sqltoast
typedef enum sql_dialect {
    SQL_DIALECT_ANSI_1992,
    SQL_DIALECT_ANSI_1999,
    SQL_DIALECT_ANSI_2003
} sql_dialect_t;

// Possible return codes from parsing
enum parse_result_code {
    PARSE_OK,
    PARSE_INPUT_ERROR,
    PARSE_SYNTAX_ERROR
};

typedef enum error {
    ERR_NONE,
    ERR_NO_CLOSING_DELIMITER
} error_t;

typedef std::vector<char> parse_input_t;

typedef parse_input_t::iterator parse_cursor_t;
typedef parse_input_t::const_iterator parse_position_t;

typedef struct lexeme {
    parse_position_t start;
    parse_position_t end;
    lexeme(
        parse_position_t start,
        parse_position_t end) :
        start(start), end(end)
    {}
    inline size_t size() const {
        return end - start;
    }
} lexeme_t;

typedef struct parse_options {
    // The dialect of SQL to parse the input with
    sql_dialect_t dialect;
    // If true, sqltoast::parse() will not attempt to create
    // sqltoast::statement objects during parsing. If all the caller is
    // interested in is determining whether a particular input is valid SQL and
    // parses to one or more SQL statements, this can reduce both the CPU time
    // taken as well as the memory usage of the parser.
    bool disable_statement_construction;
} parse_options_t;

typedef struct parse_result {
    parse_result_code code;
    std::string error;
    // As each SQL statement in an input stream is successfully parsed, a
    // sqltoast::statement derived object will be dynamically allocated and
    // pushed onto this vector
    std::vector<std::unique_ptr<statement>> statements;
} parse_result_t;

parse_result_t parse(parse_input_t& subject);
parse_result_t parse(parse_input_t& subject, parse_options_t &opts);

} // namespace sqltoast

#endif /* SQLTOAST_H */
